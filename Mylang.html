<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable,
.markdown-body .highlighttable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr,
.markdown-body .highlighttable {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite,
.markdown-body .highlighttable pre,
.markdown-body .highlighttable div.highlight {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td,
.markdown-body .highlighttable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  border-radius: 3px;
}

.markdown-body code:not(.highlight):not(.codehilite), .markdown-body samp {
  background-color: rgba(0,0,0,0.04);
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite,
.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
}

.markdown-body .codehilite,
.markdown-body .highlight,
.markdown-body pre {
  border-radius: 3px;
}

.markdown-body :not(.highlight) > pre {
  background-color: #f7f7f7;
}

.markdown-body .codehilite pre,
.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

.markdown-body diagram-div, .markdown-body div.uml-sequence-diagram, .markdown-body, div.uml-flowchart {
  overflow: auto;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*GitHub*/
.highlight {background-color:#f7f7f7;color:#333333;}
.highlight .hll {background-color:#ffffcc;}
.highlight .c{color:#999988;font-style:italic}
.highlight .err{color:#a61717;background-color:#e3d2d2}
.highlight .k{font-weight:bold}
.highlight .o{font-weight:bold}
.highlight .cm{color:#999988;font-style:italic}
.highlight .cp{color:#999999;font-weight:bold}
.highlight .c1{color:#999988;font-style:italic}
.highlight .cs{color:#999999;font-weight:bold;font-style:italic}
.highlight .gd{color:#000000;background-color:#ffdddd}
.highlight .ge{font-style:italic}
.highlight .gr{color:#aa0000}
.highlight .gh{color:#999999}
.highlight .gi{color:#000000;background-color:#ddffdd}
.highlight .go{color:#888888}
.highlight .gp{color:#555555}
.highlight .gs{font-weight:bold}
.highlight .gu{color:#800080;font-weight:bold}
.highlight .gt{color:#aa0000}
.highlight .kc{font-weight:bold}
.highlight .kd{font-weight:bold}
.highlight .kn{font-weight:bold}
.highlight .kp{font-weight:bold}
.highlight .kr{font-weight:bold}
.highlight .kt{color:#445588;font-weight:bold}
.highlight .m{color:#009999}
.highlight .s{color:#dd1144}
.highlight .n{color:#333333}
.highlight .na{color:teal}
.highlight .nb{color:#0086b3}
.highlight .nc{color:#445588;font-weight:bold}
.highlight .no{color:teal}
.highlight .ni{color:purple}
.highlight .ne{color:#990000;font-weight:bold}
.highlight .nf{color:#990000;font-weight:bold}
.highlight .nn{color:#555555}
.highlight .nt{color:navy}
.highlight .nv{color:teal}
.highlight .ow{font-weight:bold}
.highlight .w{color:#bbbbbb}
.highlight .mf{color:#009999}
.highlight .mh{color:#009999}
.highlight .mi{color:#009999}
.highlight .mo{color:#009999}
.highlight .sb{color:#dd1144}
.highlight .sc{color:#dd1144}
.highlight .sd{color:#dd1144}
.highlight .s2{color:#dd1144}
.highlight .se{color:#dd1144}
.highlight .sh{color:#dd1144}
.highlight .si{color:#dd1144}
.highlight .sx{color:#dd1144}
.highlight .sr{color:#009926}
.highlight .s1{color:#dd1144}
.highlight .ss{color:#990073}
.highlight .bp{color:#999999}
.highlight .vc{color:teal}
.highlight .vg{color:teal}
.highlight .vi{color:teal}
.highlight .il{color:#009999}
.highlight .gc{color:#999;background-color:#EAF2F5}
</style><title>Mylang</title></head><body><article class="markdown-body"><h1 id="mylang">Mylang<a class="headerlink" href="#mylang" title="Permanent link"></a></h1>
<p>Mylang is a language that looks like Python, but generates code more like Rust or Go. Statically typed, Strongly typed, duck typed with infered typing.</p>
<h1 id="hello-world">Hello world!<a class="headerlink" href="#hello-world" title="Permanent link"></a></h1>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span>
</pre></div>

<p>Above is a hello world application that computes the roughly the following in rust (Note that def main is the program entry point and is required):</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="static-typing">Static typing<a class="headerlink" href="#static-typing" title="Permanent link"></a></h1>
<p>Mylang is statically typed but we use infered typing, see the following example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
</pre></div>

<p>In the example the arguments passed to add are two integers, so <code>add</code> is implemented as such:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>The function paramater types are deduced from usage. All variables are automatically set to mutable. Note how the return type of the <code>add</code> function is also deduced from the return call.</p>
<h1 id="duck-typing">Duck typing<a class="headerlink" href="#duck-typing" title="Permanent link"></a></h1>
<p>Consider a custom class that implements the &lsquo;__str__&lsquo; function. This function, similar to the Python version, will convert the type to a string. We can create a function to take a value and convert it to a string. So we can use it as follows:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Custom1</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Custom Class!&quot;</span>

<span class="k">class</span> <span class="nc">Custom2</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Custom Class 2!&quot;</span>

<span class="k">def</span> <span class="nf">convert_to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">Custom1</span><span class="p">()</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">Custom2</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="n">convert_to_string</span><span class="p">(</span><span class="n">c1</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">convert_to_string</span><span class="p">(</span><span class="n">c2</span><span class="p">))</span>
</pre></div>

<p>The ducktyping focuses on the <code>conver_to_string</code> method in the following way:</p>
<ol>
<li>First we obtain a list of all calls to this function.</li>
<li>For each call, we identify the argument types for each paramater. In this example we have <code>Custom1</code> and <code>Custom2</code>.</li>
<li>Then we check the body of <code>convert_to_string</code> for any functions used on these paramaters. In this example we just have the <code>str</code> function which is syntactic sugar for  <code>x.__str__()</code> function.</li>
<li>If any of the functions called are not defined for the paramater, an error is thrown. This does not happen in this case as <code>__str__</code> is defined for <code>Custom1</code> and <code>Custom2</code></li>
<li>Otherwise, one Rust function for each combination of different paramaters is made. In this example just two functions, one to take a <code>Custom1</code> and another for the <code>Custom2</code></li>
</ol>
<p>The output looks a little something like</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Custom1</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Custom1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Custom1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Custom Class!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">Custom2</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Custom2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Custom2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Custom Class 2!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">convert_to_string_Custom1</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">Custom1</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">__str__</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">convert_to_string_Custom2</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">Custom2</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">__str__</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Custom1</span><span class="o">::</span><span class="n">__init__</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Custom2</span><span class="o">::</span><span class="n">__init__</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">convert_to_string_Custom1</span><span class="p">(</span><span class="n">c1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">convert_to_string_Custom2</span><span class="p">(</span><span class="n">c2</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Some important side notes on the above example:</p>
<ul>
<li>Even though <code>__str__</code> doesn&rsquo;t use self and is a member function and NOT static because it is invoked as a member function (i.e. it is called as x.y not CLASS.y). To solve this we add the <code>&amp; mut self</code> variable to the rust function to force Rust to treat it as a member function.</li>
<li>Class constructors use <code>__init__</code> which is implemented as a static function in rust.</li>
<li>Because <code>Custom1</code> and <code>Custom2</code> have no member variables, they must be implemented in rust as <code>struct Custom1;</code> and <code>struct Custom2;</code></li>
<li>When using static strings, we use <code>&amp; 'static str</code></li>
<li><code>__str__</code> must return a string to work correctly. However generally the return type is deduced.</li>
<li>All the member variables used are declared in the constructor. If a mamber variable that was not instantiated in the constructor is used elsewhere, this is an error.</li>
<li>Also everything is mutable by default. Sorry Rust :(</li>
</ul>
<p>Finally, the <code>convert_to_string</code> function is only to demonstrate duck typing and is not actually needed. The <code>print</code> function automatically calls <code>__str__</code> on all built in types anyway, so </p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Custom1</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Custom Class!&quot;</span>

<span class="k">class</span> <span class="nc">Custom2</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;Custom Class 2!&quot;</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">Custom1</span><span class="p">()</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">Custom2</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>
</pre></div>

<p>would evaluate to</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Custom1</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Custom1</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Custom1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Custom Class!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">Custom2</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Custom2</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Custom2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Custom Class 2!&quot;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Custom1</span><span class="o">::</span><span class="n">__init__</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Custom2</span><span class="o">::</span><span class="n">__init__</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">c1</span><span class="p">.</span><span class="n">__str__</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">.</span><span class="n">__str__</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="function-overloading">Function overloading<a class="headerlink" href="#function-overloading" title="Permanent link"></a></h1>
<p>Functions can be overloaded provided there is no ambiguity between overloads:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Custom3</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">custom_function</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Custom Class!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">custom_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">c3</span> <span class="o">=</span> <span class="n">Custom3</span><span class="p">()</span>

    <span class="n">c3</span><span class="o">.</span><span class="n">custom_function</span><span class="p">()</span>
    <span class="n">c3</span><span class="o">.</span><span class="n">custom_function</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Custom3</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Custom3</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Custom3</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">custom_function</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Custom Class!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">custom_function_int</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Custom3</span><span class="o">::</span><span class="n">__init__</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="n">c3</span><span class="p">.</span><span class="n">custom_function</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">c3</span><span class="p">.</span><span class="n">custom_function_int</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="rust-enums">Rust Enums<a class="headerlink" href="#rust-enums" title="Permanent link"></a></h1>
<p>We use rust enums because they are king:</p>
<div class="highlight"><pre><span class="n">enum</span> <span class="n">Collection</span><span class="p">:</span>
    <span class="bp">None</span>
    <span class="n">One</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">Many</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

<h1 id="by-reference">By reference<a class="headerlink" href="#by-reference" title="Permanent link"></a></h1>
<p>While primitive built in and user defined types are instantiated on the stack and coopied when moved by value, built in containers and most user defined classes are instantiated on the heap and passed by reference:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">subtract_2</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
        <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">subtract_2</span><span class="p">(</span><span class="n">lst</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">subtract_2</span><span class="p">(</span><span class="n">l</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.</span><span class="p">.</span><span class="n">l</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">lst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">subtract_2</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">lst</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">lst</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="rust-result">Rust Result<a class="headerlink" href="#rust-result" title="Permanent link"></a></h1>
<p>We use Rust error handling because exception based error handling is less than ideal. Instead we use Rust&rsquo;s error handling which is based on <code>Result</code> which is a special value that can either be <code>Ok</code> and have a sucess/return value associated with it, or <code>Err</code> indicating failure and have an error value. To return <code>Ok</code> we simply return a value as normal. To return an error we use the <code>error</code> function. The <code>error</code> function can take any value that implements the <code>__error__</code> function. By default, when a function returns a <code>Result</code> this result <code>unwraps</code>, returning the success value if succeeded, and panicing if there is an error. Take the following example:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">(</span><span class="s">&quot;Divide by zero!&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">divide</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>
    <span class="c1"># print(divide(4.0, 0.0)) # Calling this function will cause a panic</span>
</pre></div>

<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&quot;Divide by zero!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0</span><span class="p">).</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>Mylang&rsquo;s static type inferance works by tracing all code paths in a function. If any one path returns a <code>error</code> then the return value is designated as <code>Result</code> and all other non-error values are wrapped in an <code>Ok</code>. As mentioned, by default, when a function that returns an <code>error</code> is called, unwrap is called on that function return value immediately. This on its own is not enough, as all <code>Results</code> will just panic. To allow actual error handling, we introduce a new statement shown below:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error</span><span class="p">(</span><span class="s">&quot;Divide by zero!&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">divide_handler</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">ok</span> <span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">as</span> <span class="n">dividend</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;{a} / {b} = {dividend}&quot;</span><span class="p">)</span>
    <span class="n">err</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;divide error - {e}&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">divide_handler</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">7.0</span><span class="p">)</span>
    <span class="n">divide_handler</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
</pre></div>

<p>The line <code>ok divide(a, b) as dividend</code> can be interpreteed as &lsquo;if the divide call returns an ok, execute the following block with dividend as the result from the divide function&rsquo;. The second block <code>err as e</code> can be interpreted as &lsquo;if the divide call returns err, execute the following block with e as the returned error&rsquo;. The ok/err block is the only time where a function returning a result is not unwrapped straight away. See the following code for clarification:</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Err</span><span class="p">(</span><span class="s">&quot;Divide by zero!&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">divide_handler</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">dividend</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{} / {} = {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">dividend</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;divide error - {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">divide_handler</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span><span class="w"> </span><span class="mf">7.0</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">divide_handler</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>NOTE: I&rsquo;m not really a fan of the ok/err syntax. I prefer something more generic like match that can be used for some/none.</p>
<h1 id="variadic-arguments">Variadic arguments?<a class="headerlink" href="#variadic-arguments" title="Permanent link"></a></h1>
<p>Variadic arguments are allowed and are implemented the same(ish) way as they are in C. Argumments are implemented as a static list on the stack. Variadic argumments can be overloaded to specify different or more optimised behaviour for a set number of arguments. All variadic arguments must be the same type. Variadic arguments must be at the end of the list. Variadic arguments are accessed with the <code>__variadic__</code> list</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="o">..</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="o">+</span><span class="n">inf</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">__variadic__</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">arg</span>

    <span class="k">return</span> <span class="n">m</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>

<div class="highlight"><pre><span class="c1">//Created from the single and double argument min calls</span>
<span class="k">fn</span><span class="w"> </span><span class="n">min___variadic___int</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">min___variadic___int_int</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//Generic function created by min(..)</span>
<span class="k">fn</span><span class="w"> </span><span class="n">min___variadic___ints</span><span class="p">(</span><span class="n">__variadic__</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="kt">i64</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">i64</span><span class="o">::</span><span class="n">MAX</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">__variadic__</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Specific implementatio of min(2, 6, 5, 9, 4)</span>
<span class="k">fn</span><span class="w"> </span><span class="n">min___variadic___int_5</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">__variadic__</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">min___variadic___ints</span><span class="p">(</span><span class="o">&amp;</span><span class="n">__variadic__</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">min___variadic___int</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">min___variadic___int_int</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">min___variadic___int_5</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="string-formatting">String formatting<a class="headerlink" href="#string-formatting" title="Permanent link"></a></h1>
<p>Think of a Rust-like way to format strings that isn&rsquo;t too bulky but is still powerful and efficient. Maybe something using <code>format</code> and <code>__format__</code>. Think of a way that doesn&rsquo;t keep concatenating or assigning new strings.</p>
<h1 id="type-table">Type table<a class="headerlink" href="#type-table" title="Permanent link"></a></h1>
<p>Tabulate all types against trait functions and show which Rust functions they invoke, like so:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>int (i64)</th>
<th>float (f64)</th>
<th>string (String)</th>
<th>bool (bool)</th>
<th>list (vec)</th>
<th>tuple</th>
<th>range (x..y)</th>
<th>set (HashSet)</th>
<th>dict (HashMap)</th>
</tr>
</thead>
<tbody>
<tr>
<td>__str__</td>
<td>i64.to_string()</td>
<td>f64.to_sting()</td>
<td>String</td>
<td>bool.to_string()</td>
<td>dunno lol</td>
<td>dunno lol</td>
<td>&ldquo;range(x, y)&rdquo;</td>
<td>dunno</td>
<td>also dunno</td>
</tr>
<tr>
<td>__len__</td>
<td></td>
<td></td>
<td>String.len</td>
<td></td>
<td>vec.len</td>
<td>compile time resolved</td>
<td>dunno lol</td>
<td>HashSet.len</td>
<td>HashMap.len</td>
</tr>
<tr>
<td>__float__</td>
<td>i64 as f64</td>
<td>return f64</td>
<td>String.parse</td>
<td>bool.parse</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>When a function listed is called on a built in type, it is converted to Rust code via the table above.</p>
<h1 id="classes">Classes<a class="headerlink" href="#classes" title="Permanent link"></a></h1>
<p>Note: While member variables can be infered, they must only have one type as this will be the types used by the Rust class. To show this, we show the following code which is valid:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">7.5</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">)</span>
</pre></div>

<p>because type inference shows that both <code>Point.x</code> and <code>Point.y</code> are floats (based on the call to <code>__init__</code>) but the following is not:</p>
<div class="highlight"><pre><span class="c1"># THIS MYLANG CODE WILL NOT COMPILE</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">7.5</span><span class="p">,</span> <span class="mf">5.4</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

<p>Because in the first call to the contructor both arguments are floats, however in the second constructor both are integers and there is no conversion, implicit or otherwise. We can solve this by modifying the contructor to convert the inputs to a float during assignment. This means that anything can be used to construct the <code>Point</code> as long as it has a <code>__float__</code> function. This gives the best of both worlds, it is clear that <code>Point</code> stores two floats, and yet we can supply non-float types as arguments at the small cost of having to explicitly call <code>float</code> on the arguments</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{self.x}i + {self.y}j&quot;</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mf">1.7</span><span class="p">,</span> <span class="mf">4.1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">_x</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="c1">// Note the prefixed underscore to all member variables to avoid confusing Rust</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">_y</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Two constructors are called, on two floates and the other on two ints so we provide functions for both</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__float_float</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">f64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_x</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="c1">//float(x) requires no conversion</span>
<span class="w">            </span><span class="n">_y</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__int_int</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_x</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="c1">//calling float(x) on an integer evaluates to &#39;x as f64&#39;</span>
<span class="w">            </span><span class="n">_y</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">f64</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__add__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">Self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="n">__init__float_float</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">_y</span><span class="p">)</span><span class="w"> </span><span class="c1">// Here we use `__init__float_float` as this is deduced from the contructor call</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}i + {}j&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_x</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="n">__init__float_float</span><span class="p">(</span><span class="mf">1.7</span><span class="p">,</span><span class="w"> </span><span class="mf">4.1</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="n">__init__int_int</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">__add__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">__str__</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">__str__</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">__str__</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="getters-and-setters">Getters and Setters<a class="headerlink" href="#getters-and-setters" title="Permanent link"></a></h1>
<p>Getters can be implemented by adding <code>__get_NAME__</code> and setters can be implemented by adding <code>__set_NAME__</code> to the class, where &lsquo;NAME&rsquo; is the name of the variable. For example:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">PropertyTest</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set_a__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Setter - {self.a}&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_a__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Getter - {self.a}&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">():</span>
        <span class="k">return</span> <span class="k">print</span><span class="p">(</span><span class="s">&quot;PropertyTest({self.a}, {self.b})&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">PropertyTest</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="s">&quot;world!&quot;</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

    <span class="n">pt</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="s">&quot;Goodbye&quot;</span>

    <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

    <span class="n">pt</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="s">&quot;everyone&quot;</span>

    <span class="k">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
</pre></div>

<p>Because <code>__set_a__</code> and <code>__get_a__</code> are implemented for <code>PropertyTest</code>, whenever <code>a</code> is assigned or fetched, these functions are used instead. More generally, <code>object.name = value</code> is evaluated to <code>object.__set_name__(value)</code> if <code>__set_name__</code> is implemented for object. Similarly, <code>value = object.name</code> is evaluated to <code>value = object.__get_name__()</code> if <code>__get_name__</code> is implemented for object. If getters or setters are not implemented default implementatons are used instead. See the Rust output below:</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">PropertyTest</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">_a</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">_b</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">PropertyTest</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__str_str</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">PropertyTest</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">_a</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="c1">// We must convert static str to heap string</span>
<span class="w">            </span><span class="n">_b</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__set_a__str</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nl">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Setter - {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_a</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__get_a__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;Getter - {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_a</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">__repr__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;PropertyTest({}, {})&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_a</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">_b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">pt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PropertyTest</span><span class="o">::</span><span class="n">__init__str_str</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world!&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">.</span><span class="n">__repr__</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">pt</span><span class="p">.</span><span class="n">__set_a__str</span><span class="p">(</span><span class="s">&quot;Goodbye&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">.</span><span class="n">__get_a__</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">.</span><span class="n">__repr__</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">pt</span><span class="p">.</span><span class="n">_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">String</span><span class="o">::</span><span class="n">from</span><span class="p">(</span><span class="s">&quot;everyone&quot;</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">.</span><span class="n">_b</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pt</span><span class="p">.</span><span class="n">__repr__</span><span class="p">());</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="somenone">Some/None<a class="headerlink" href="#somenone" title="Permanent link"></a></h1>
<p>Mylang contains the <code>None</code> keyword as a pairing with the <code>some</code> function. This works as it does in python. We can use <code>some(5)</code> or <code>None</code> to represent a present value of 5, or an absent value, respectively. The some/none statement can be used to extract the inner value if there is one, similar to using <code>match</code> in rust:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">some</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">test_first</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">as</span> <span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;x contains a some({val})&quot;</span><span class="p">)</span>
    <span class="n">none</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;x does not contain a value&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">test_first</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span>
    <span class="n">test_first</span><span class="p">([])</span>
</pre></div>

<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">None</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">test_first</span><span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">first</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;x contains some ({})&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;x does not contain a value&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">test_first</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">]);</span><span class="w"></span>
<span class="w">    </span><span class="n">test_first</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="privacy">Privacy<a class="headerlink" href="#privacy" title="Permanent link"></a></h1>
<p>By default, member variables are all public. However, prefixing the name with the double underscore (&ldquo;__&ldquo;) and making sure there are no trailing underscores, marks the variable as private. This means that it can only be accessed from within the class. Getters and setters can still be provided, but they can only be accessed from within the class too.</p>
<h1 id="deduction-problems">Deduction problems?<a class="headerlink" href="#deduction-problems" title="Permanent link"></a></h1>
<p>Take the following example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">&quot;hello&quot;</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">v</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">())</span>
</pre></div>

<p>It is impossible to determine which version of <code>f</code> is called since <code>str</code> is defined for integers and strings. Maybe the solution to this is NOT to allow function overloading by the user. Overloading should only be performed by the compiler for generating functions that take and return different types.</p>
<h1 id="stackorheap">Heap Vs Stack<a class="headerlink" href="#stackorheap" title="Permanent link"></a></h1>
<p>Yes, I know, you hate the stack vs heap debate as much as I do. Here we follow a similar strategy to Python: Built-in primitives on the stack, everything else on the heap. The one exception to this is any user created types that behave like built-in primitives. That is, any user created types that are:</p>
<p>a) Simple - Types that do not contain any references (or any child objects) as this would be incompatible with copying and passing by value
b) Small - Types that are only a handful of machine words long. Larger types incur a larger overhead to copy when passing by value
c) Immutable - Immutable types cannot be modified so can be passed around by value and treated the same way as other types.</p>
<p>Stack types are passed by value and copied around, whereas heap types are passed by reference.</p>
<p>An example of a custom type that would be implemened on the stack is the <code>Point</code> class from the previous example, because:</p>
<p>a) it contains no references
b) it is only 2 floats long
c) It is immutable as none of the member functions alter the member variables. </p>
<h1 id="reference-counting-cycles-and-the-heap">Reference counting, cycles and the heap<a class="headerlink" href="#reference-counting-cycles-and-the-heap" title="Permanent link"></a></h1>
<p>As mentioned above, stack objects are passed by value and heap values are passed by reference. Heap values are reference counter to automatically free when no longer root accessible. This of course does not clean up cycles, so we have a special reference counted type that scans for and frees inacessible cycles. This more complex form of reference counting can free cycles, but comes with extra overhead that normal non-cycle types don&rsquo;t need. </p>
<p>To solve this issue, the compiler scans all variables and class variables to determine if any of them have the capacity to form cycles. For types and variables that are definitely not part of cycles, regular reference counting is used. For any types and variables that MIGHT produce cycles, the special reference counting is used.</p>
<h1 id="non-cyclic-references">Non-cyclic references<a class="headerlink" href="#non-cyclic-references" title="Permanent link"></a></h1>
<p>Take the following example and its translation to see how we handle simple references and heap objects:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">minus_2</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)):</span>
        <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">l</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">minus_2</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</pre></div>

<p>In the example, note that the only heap object is a list, and it is a list of integers, so is not cyclic.</p>
<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="p">{</span><span class="n">UnsafeCell</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span><span class="p">,</span><span class="w"> </span><span class="n">Ref</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">dumpster</span><span class="o">::</span><span class="p">{</span><span class="n">Collectable</span><span class="p">,</span><span class="w"> </span><span class="n">unsync</span><span class="o">::</span><span class="n">Gc</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">borrow</span><span class="o">::</span><span class="n">Borrow</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rc</span><span class="o">::</span><span class="n">Rc</span><span class="p">;</span><span class="w"></span>


<span class="c1">// Reference counted cell type aliases for improved readability</span>
<span class="k">type</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Functions used to obtain a mutable reference from an unsafe cell for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Functions to create new CellGc and CellRc objects for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">new_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Gc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">new_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">minus_2</span><span class="p">(</span><span class="n">l</span><span class="o">:</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u64</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.</span><span class="p">.(</span><span class="o">*</span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">)).</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_rc</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">]);</span><span class="w"></span>

<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">minus_2</span><span class="p">(</span><span class="n">test</span><span class="p">.</span><span class="n">clone</span><span class="p">())));</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="p">));</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>

<p>See how <code>test</code> is implemented as a reference counted heap object.</p>
<h1 id="cycles">Cycles<a class="headerlink" href="#cycles" title="Permanent link"></a></h1>
<p>In this example, we give a simple cyclic reference that uses the advanced reference counter to clean up:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">set_b</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">some</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">link</span><span class="p">():</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">b</span><span class="o">.</span><span class="n">set_b</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># At this point a and b form a cyclic reference</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">link</span><span class="p">()</span>
</pre></div>

<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="p">{</span><span class="n">UnsafeCell</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span><span class="p">,</span><span class="w"> </span><span class="n">Ref</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">dumpster</span><span class="o">::</span><span class="p">{</span><span class="n">Collectable</span><span class="p">,</span><span class="w"> </span><span class="n">unsync</span><span class="o">::</span><span class="n">Gc</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">borrow</span><span class="o">::</span><span class="n">Borrow</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rc</span><span class="o">::</span><span class="n">Rc</span><span class="p">;</span><span class="w"></span>


<span class="c1">// Reference counted cell type aliases for improved readability</span>
<span class="k">type</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Functions used to obtain a mutable reference from an unsafe cell for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Functions to create new CellGc and CellRc objects for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">new_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Gc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">new_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Collectable)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">a</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Collectable)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">set_b</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">link</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">B</span><span class="o">::</span><span class="n">new</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">).</span><span class="n">set_b</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="n">link</span><span class="p">();</span><span class="w"></span>

<span class="p">}</span><span class="w"></span>
</pre></div>

<p>The compiler recognises that <code>A</code> and <code>B</code> are at risk of forming cyclic references, so we use <code>Gc</code> to reference count and check cycles.</p>
<h1 id="mixed-approach">Mixed approach<a class="headerlink" href="#mixed-approach" title="Permanent link"></a></h1>
<p>Objects that point into a cycle can be normal reference counted. And objects in a cycle can point to normal reference counted objects. This means that we can maximise the use of normal, fast reference counting. See the following example:</p>
<h1 id="realistic-example">Realistic example<a class="headerlink" href="#realistic-example" title="Permanent link"></a></h1>
<p>The examples above are useful, but a bit abstract. Here we create a parent/child system with a manager class that holds the parent:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Child</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Parent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Manager</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">head</span>

    <span class="k">def</span> <span class="nf">kids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">children</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Parent</span><span class="p">()</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">c_1</span> <span class="o">=</span> <span class="n">Child</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c_2</span> <span class="o">=</span> <span class="n">Child</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">c_3</span> <span class="o">=</span> <span class="n">Child</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">p</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c_1</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c_2</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">add_child</span><span class="p">(</span><span class="n">c_3</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">kids</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</pre></div>

<div class="highlight"><pre><span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cell</span><span class="o">::</span><span class="p">{</span><span class="n">UnsafeCell</span><span class="p">,</span><span class="w"> </span><span class="n">RefCell</span><span class="p">,</span><span class="w"> </span><span class="n">Ref</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">dumpster</span><span class="o">::</span><span class="p">{</span><span class="n">Collectable</span><span class="p">,</span><span class="w"> </span><span class="n">unsync</span><span class="o">::</span><span class="n">Gc</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">borrow</span><span class="o">::</span><span class="n">Borrow</span><span class="p">;</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rc</span><span class="o">::</span><span class="n">Rc</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Reference counted cell type aliases for improved readability</span>
<span class="k">type</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Functions used to obtain a mutable reference from an unsafe cell for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Functions to create new CellGc and CellRc objects for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">new_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Gc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">new_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="cp">#[derive(Collectable)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">Child</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">parent</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Parent</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Child</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Parent</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="o">:</span><span class="w"> </span><span class="kt">u64</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Child</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">parent</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">id</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">id</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="cp">#[derive(Collectable)]</span><span class="w"></span>
<span class="k">struct</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">children</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Child</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="c1">// Vecs must be wrapped in a rc, and it is a vector of rc children. got it?</span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Parent</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">children</span><span class="o">:</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">Vec</span><span class="o">::</span><span class="n">new</span><span class="p">()),</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">add_child</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Child</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">children</span><span class="p">).</span><span class="n">push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">Manager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">head</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Parent</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Manager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">(</span><span class="n">head</span><span class="o">:</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Parent</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Manager</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">head</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">kids</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">Child</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">).</span><span class="n">children</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">Parent</span><span class="o">::</span><span class="n">__init__</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">manager</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_rc</span><span class="p">(</span><span class="n">Manager</span><span class="o">::</span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">clone</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">Child</span><span class="o">::</span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">Child</span><span class="o">::</span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">c_3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_gc</span><span class="p">(</span><span class="n">Child</span><span class="o">::</span><span class="n">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">).</span><span class="n">add_child</span><span class="p">(</span><span class="n">c_1</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">).</span><span class="n">add_child</span><span class="p">(</span><span class="n">c_2</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">).</span><span class="n">add_child</span><span class="p">(</span><span class="n">c_3</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">thing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">thing2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">);</span><span class="w"></span>


<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">manager</span><span class="p">).</span><span class="n">kids</span><span class="p">()).</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="p">(</span><span class="n">child</span><span class="p">).</span><span class="n">__str__</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="fallbacks">Fallbacks<a class="headerlink" href="#fallbacks" title="Permanent link"></a></h1>
<p>Dynamic ducktyping allows for fallbacks by testing if an object implements a function then making decisions on these tests. For example, in python the <code>__str__</code> provides a function that is used to represent an object as a string. However, if this function is not defined, <code>__repr__</code> is used as a fallback. To fascilitate this, we allow multiple functions with the same signature and return value to be defined. For a given call, the compiler will try each of these functions until it finds one that works for the arguments:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>In the above example, when <code>to_string</code> is called on a parameter, say named <code>y</code>, the compiler will first try the first implementation. It will test any functions called on <code>y</code> to make sure they hold. The only function is <code>str</code> and this is implemented as calling the object&rsquo;s <code>__str__</code>, so if it is defined, <code>str</code> is defined and therefore so is <code>to_string</code>, so a <code>to_string</code> is created to accept <code>y</code> as an argument. If however this first implementation is not compatible with <code>y</code> it tries the next. If all functions are not compatible a compile time error is produced. </p>
<p>In the example above the compiler tries the functions in the order they are written. A different order can be specified with <code>@fallback n</code>:</p>
<div class="highlight"><pre><span class="nd">@fallback</span> <span class="mi">2</span>
<span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="nd">@fallback</span> <span class="mi">1</span>
<span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>in the above example the order is reversed. </p>
<h1 id="special-functions">Special functions<a class="headerlink" href="#special-functions" title="Permanent link"></a></h1>
<p>Special functions work similarly to how they work in Python, and some of them have arguments or return values with explicit types. If these explicit types are not respected when implementing special functions on custom classes, this is an error.</p>
<h1 id="maps">Maps<a class="headerlink" href="#maps" title="Permanent link"></a></h1>
<p>Maps with mutable keys is a logic error. To avoid this, we take a similar approach to python. There are three cases:</p>
<ul>
<li>Stack objects: Stack objects are copied into the map and their hashes are computed over all fields.</li>
<li>Built in heap objects:<ul>
<li>mutable: Cannot be used in hash maps. A compile time error will be produced</li>
<li>immutable: These are a special variant of the usual list, string, etc. that are immutable and specifically created for use in hash keys. Objects are copied by reference and hashes are computed for each item in the collection.</li>
</ul>
</li>
<li>User defined heap objects: Objects are copied by reference and the hash is computed on the reference itself.</li>
</ul>
<p>Another note for maps is that any map that is a) known at compile time and b) immutable can be implemented as a phf via the <code>Rust-PHF</code> crate.</p>
<h1 id="serde">Serde<a class="headerlink" href="#serde" title="Permanent link"></a></h1>
<p>Serialisation and deserialisation similar to Rust Serde crate. Special functions <code>__se__</code> and <code>__de__</code> can be used to convert an object to bytes, and use a stream of bytes to instantiate objects, respectively. </p>
<h1 id="readwrite">Read/Write<a class="headerlink" href="#readwrite" title="Permanent link"></a></h1>
<p>Functions similar to how they work in Rust, <code>__read__</code> and <code>__write__</code></p>
<h1 id="id">Id<a class="headerlink" href="#id" title="Permanent link"></a></h1>
<p>Every object has the <code>id</code> function that returns the address of the object as a special type <code>Id</code> (which is implemented as <code>usize</code>). We have special functions for RC and GC that obtain unique references pointing to the heap. For stack variables we can do something like transmute.</p>
<h1 id="paths">Paths<a class="headerlink" href="#paths" title="Permanent link"></a></h1>
<p>Use a <code>__path__</code> function in calls like <code>open()</code> to convert objects to path objects of type <code>Path</code> which is the same as Rust&rsquo;s <code>std::path::Path</code>. By default, <code>__path__</code> calls <code>__str__</code> and converts it into a path object.</p>
<h1 id="drop">Drop<a class="headerlink" href="#drop" title="Permanent link"></a></h1>
<p>Use <code>__del__</code> to call the objects destructor via Rust&rsquo;s drop interface.</p>
<h1 id="complex-numbers">Complex numbers<a class="headerlink" href="#complex-numbers" title="Permanent link"></a></h1>
<p>Complex numbers are implemented with the <code>complex</code> class which exposes two special functions, <code>__real__</code> and <code>__imag__</code> that return the real and imaginary parts of the complex number, respectively. Floats, ints and other real number values expose <code>__real__</code> (which returns the number) and <code>__imag__</code> (which returns 0), since these numbers are complex numbers with imaginary part 0. Note: Complex numbers do not implement <code>__float__</code>, <code>__int__</code> or <code>__index__</code></p>
<h1 id="profiling-testing-and-benchmarking">Profiling, testing and benchmarking<a class="headerlink" href="#profiling-testing-and-benchmarking" title="Permanent link"></a></h1>
<p>Yes, yes and yes, all built in.</p>
<h1 id="compiler-checks">Compiler checks<a class="headerlink" href="#compiler-checks" title="Permanent link"></a></h1>
<ul>
<li>Inferring types from literal values and return types</li>
<li>Constructing overloaded functions for each call</li>
<li>Checking that types have the functions that we call via duck typing</li>
<li>Checking for classes that are at risk of producing cycles</li>
<li>Checking for variables that are at risk of producing cycles</li>
<li>Check for any mutable call to a built in collection inside iteration (avoiding iterator invalidation)</li>
<li>Make sure the mutable built in collections are never used as keys in dictionaries</li>
<li>Figure out whether custom types are mutable or immutable. If class fields are never changed (eitehr by internal functions or externally accessing fields) the class is immutable. Otherwise it is mutable.</li>
</ul>
<h1 id="returning-object-references">Returning object references<a class="headerlink" href="#returning-object-references" title="Permanent link"></a></h1>
<p>Take the following</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>

    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">55</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">make</span><span class="p">())</span>
</pre></div>

<p>instead of returning a clone of <code>a</code> (if we returned a clone then the reference count would be incremented when we clone, and decremented when <code>a</code> falls out of scope) we just return <code>a</code> itself:</p>
<div class="highlight"><pre><span class="c1">// Reference counted cell type aliases for improved readability</span>
<span class="k">type</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>
<span class="k">type</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Functions used to obtain a mutable reference from an unsafe cell for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">UnsafeCell</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">as_mut</span><span class="p">().</span><span class="n">unwrap</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Functions to create new CellGc and CellRc objects for improved readability</span>
<span class="k">fn</span><span class="w"> </span><span class="n">new_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Gc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">new_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Rc</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">UnsafeCell</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">//Get the IDs of gc and rc objects</span>
<span class="k">fn</span><span class="w"> </span><span class="n">gc_id</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellGc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">usize</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Gc</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">as_id</span><span class="p">(</span><span class="n">t</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">rc_id</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">Collectable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">usize</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Rc</span><span class="o">::&lt;</span><span class="n">_</span><span class="o">&gt;::</span><span class="n">as_ptr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">usize</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="kt">i64</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">__init__</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">list</span><span class="o">:</span><span class="w"> </span><span class="n">new_rc</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[]),</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">append</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">list</span><span class="p">).</span><span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">__str__</span><span class="p">(</span><span class="o">&amp;</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">format</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">list</span><span class="p">))</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">make</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">CellRc</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_rc</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">__init__</span><span class="p">());</span><span class="w"></span>

<span class="w">    </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">).</span><span class="n">append</span><span class="p">(</span><span class="mi">55</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">mut_ref_rc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">make</span><span class="p">()).</span><span class="n">__str__</span><span class="p">())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h1 id="pythons-ast">Python&rsquo;s AST<a class="headerlink" href="#pythons-ast" title="Permanent link"></a></h1>
<h2 id="type-inferance">Type inferance<a class="headerlink" href="#type-inferance" title="Permanent link"></a></h2>
<p>Whenever we assign to a value we look to the expression to determine the type. Assignments can come in many forms:</p>
<ul>
<li><code>x = 2</code>: Here we can deduce the type of the LHS by seeing the type of the RHS. </li>
<li><code>for a in b</code>: This example is slightly more complex. Here we need to determine the type of <code>a</code> based on <code>b</code>. <code>b</code> must have <code>__iter__</code> defined, and this iter must have a <code>__next__</code> function. <code>__next__</code> returns <code>Option&lt;T&gt;</code> for some type <code>T</code>, and its this type that belongs to our variable <code>a</code>.</li>
<li>some/none and ok/err matching statements: Based on the return value from the values passed to the match statements.</li>
</ul>
<p>For each assignment, we look to the targets (LHS of assignment) and we identify them by scope (this allows two variables of the same name to be treated separately if they are in separate scopes), then we look at the expression (RHS of assignment) and treat the targets type as the same as the assignment.</p>
<h2 id="stack-or-heap">Stack or Heap<a class="headerlink" href="#stack-or-heap" title="Permanent link"></a></h2>
<p>For every user defined class, we must decide at compile time whether class instances will exist on the stack or heap. To do this we test for the conditions outlined <a href="#stackorheap">here</a>. Here we outline more rigorous requirements:</p>
<p>a) No references - The user defined class must not contain references to other user defined class, or built in containers that exist on the heap. 
b) Small - The size, in bytes, of the user defined class must be less than some threshold.
c) Immutable - To be immutable, assignment of member variables must ONLY happen within the <code>__init__</code> call. Assignments in member functions, or on public fields outside the class will result in the class being marked as a mutable type.</p>
<p>If all three of these requirements are met, the class is marked as a stack object and is moved around by value. In Rust we implement the copy trait for these objects.</p>
<h2 id="rc-or-gc">RC or GC<a class="headerlink" href="#rc-or-gc" title="Permanent link"></a></h2>
<p>After type inferrance has been completed, the compiler can walk over all types that can contain references (built in containers and user defined types) and follows any fields or elements that contain references. If cycles are found, all variables involved are allocated using GC. Otherwise RC is used.</p>
<h2 id="mylang-ast">Mylang AST<a class="headerlink" href="#mylang-ast" title="Permanent link"></a></h2>
<p>The Mylanf AST is similar to the Python AST, but it excludes things like with statements, match statements and error handling statements and incudes extra statically obtained information (type, heap or stack, RC or GC) and other statements like the some/none and the ok/err.</p>
<p>For all variables, the AST contains extra information on top of the information in the Python AST including:</p>
<ul>
<li>Stack or Heap: Indicator stating whether the type is declared on the stack or heap, as defined by the rules above</li>
<li>RC or GC: Does the variable use normal reference counting (via Rust&rsquo;s std) or does it use RC with cycle detection (using dumpster)</li>
</ul>
<p>We also include extra statements:</p>
<ul>
<li>some/none: some_none(expr value, expr target, stmt* some_body, stmt* none_body) where value is the expression contained the <code>Option</code>, target is the some inner value, some_body is the body of the some arm, and none_body is the body of the none arm.</li>
<li>ok/err: ok_err(Call value, expr ok_target, expr err_target, stmt* ok_body, stmt* err_body) where value is a function call returning a <code>Result</code>, ok_target is the <code>Ok</code> inner value, err_target is the <code>Err</code> value, ok_body is the body of the ok arm, and err_body is the body of the err arm.</li>
</ul>
<h1 id="mylang-grammar">Mylang Grammar<a class="headerlink" href="#mylang-grammar" title="Permanent link"></a></h1>
<p>Mylang grammar is as follows:</p>
<pre><span></span><span class="c c-Singleline">-- ASDL's 4 builtin types are:</span>
<span class="c c-Singleline">-- identifier, int, string, constant</span>

<span class="k">module</span> <span class="nt">Mylang</span>
<span class="p">{</span>
    <span class="n">stmt</span> <span class="o">=</span> <span class="nc">FunctionDef</span><span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">name</span>, <span class="bp">arguments</span><span class="o"> </span><span class="n">args</span>,
                       <span class="bp">stmt</span><span class="o">* </span><span class="n">body</span>, <span class="bp">expr</span><span class="o">* </span><span class="n">decorator_list</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">returns</span>,
                       <span class="bp">string</span><span class="o">? </span><span class="n">type_comment</span>, <span class="bp">type_param</span><span class="o">* </span><span class="n">type_params</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">ClassDef</span><span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">name</span>,
             <span class="bp">keyword</span><span class="o">* </span><span class="n">keywords</span>,
             <span class="bp">stmt</span><span class="o">* </span><span class="n">body</span>,
             <span class="bp">expr</span><span class="o">* </span><span class="n">decorator_list</span>,
             <span class="bp">type_param</span><span class="o">* </span><span class="n">type_params</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">Return</span><span class="p">(</span><span class="bp">expr</span><span class="o">? </span><span class="n">value</span><span class="p">)</span>

          <span class="o">|</span> <span class="nc">Assign</span><span class="p">(</span><span class="bp">expr</span><span class="o">* </span><span class="n">targets</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">value</span>, <span class="bp">string</span><span class="o">? </span><span class="n">type_comment</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">AugAssign</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">target</span>, <span class="bp">operator</span><span class="o"> </span><span class="n">op</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">value</span><span class="p">)</span>
          <span class="c c-Singleline">-- 'simple' indicates that we annotate simple name without parens</span>
          <span class="o">|</span> <span class="nc">AnnAssign</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">target</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">annotation</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">value</span>, <span class="bp">int</span><span class="o"> </span><span class="n">simple</span><span class="p">)</span>

          <span class="c c-Singleline">-- use 'orelse' because else is a keyword in target languages</span>
          <span class="o">|</span> <span class="nc">For</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">target</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">iter</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">body</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">orelse</span>, <span class="bp">string</span><span class="o">? </span><span class="n">type_comment</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">While</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">test</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">body</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">orelse</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">If</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">test</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">body</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">orelse</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">SomeNone</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">value</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">target</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">some_body</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">none_body</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">OkErr</span><span class="p">(</span><span class="bp">Call</span><span class="o"> </span><span class="n">value</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">ok_target</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">err_target</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">ok_body</span>, <span class="bp">stmt</span><span class="o">* </span><span class="n">err_body</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">Assert</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">test</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">msg</span><span class="p">)</span>

          <span class="o">|</span> <span class="nc">Expr</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">value</span><span class="p">)</span>
          <span class="o">|</span> <span class="nc">Pass</span> <span class="o">|</span> <span class="nc">Break</span> <span class="o">|</span> <span class="nc">Continue</span>

          <span class="c c-Singleline">-- col_offset is the byte offset in the utf8 string the parser uses</span>
          <span class="nb">attributes</span> <span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">col_offset</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_lineno</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_col_offset</span><span class="p">)</span>

          <span class="c c-Singleline">-- BoolOp() can use left &amp; right?</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="nc">BoolOp</span><span class="p">(</span><span class="bp">boolop</span><span class="o"> </span><span class="n">op</span>, <span class="bp">expr</span><span class="o">* </span><span class="n">values</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">BinOp</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">left</span>, <span class="bp">operator</span><span class="o"> </span><span class="n">op</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">right</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">UnaryOp</span><span class="p">(</span><span class="bp">unaryop</span><span class="o"> </span><span class="n">op</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">operand</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Lambda</span><span class="p">(</span><span class="bp">arguments</span><span class="o"> </span><span class="n">args</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">body</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">IfExp</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">test</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">body</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">orelse</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Dict</span><span class="p">(</span><span class="bp">expr</span><span class="o">* </span><span class="n">keys</span>, <span class="bp">expr</span><span class="o">* </span><span class="n">values</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Set</span><span class="p">(</span><span class="bp">expr</span><span class="o">* </span><span class="n">elts</span><span class="p">)</span>
         <span class="c c-Singleline">-- need sequences for compare to distinguish between</span>
         <span class="c c-Singleline">-- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3</span>
         <span class="o">|</span> <span class="nc">Compare</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">left</span>, <span class="bp">cmpop</span><span class="o">* </span><span class="n">ops</span>, <span class="bp">expr</span><span class="o">* </span><span class="n">comparators</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Call</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">func</span>, <span class="bp">expr</span><span class="o">* </span><span class="n">args</span>, <span class="bp">keyword</span><span class="o">* </span><span class="n">keywords</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">FormattedValue</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">value</span>, <span class="bp">int</span><span class="o"> </span><span class="n">conversion</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">format_spec</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">JoinedStr</span><span class="p">(</span><span class="bp">expr</span><span class="o">* </span><span class="n">values</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Constant</span><span class="p">(</span><span class="bp">constant</span><span class="o"> </span><span class="n">value</span>, <span class="bp">string</span><span class="o">? </span><span class="n">kind</span><span class="p">)</span>

         <span class="c c-Singleline">-- the following expression can appear in assignment context</span>
         <span class="o">|</span> <span class="nc">Attribute</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">value</span>, <span class="bp">identifier</span><span class="o"> </span><span class="n">attr</span>, <span class="bp">expr_context</span><span class="o"> </span><span class="n">ctx</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Subscript</span><span class="p">(</span><span class="bp">expr</span><span class="o"> </span><span class="n">value</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">slice</span>, <span class="bp">expr_context</span><span class="o"> </span><span class="n">ctx</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Name</span><span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">id</span>, <span class="bp">expr_context</span><span class="o"> </span><span class="n">ctx</span>, <span class="bp">topology</span><span class="o"> </span><span class="n">t</span>, <span class="bp">location</span><span class="o"> </span><span class="n">l</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">List</span><span class="p">(</span><span class="bp">expr</span><span class="o">* </span><span class="n">elts</span>, <span class="bp">expr_context</span><span class="o"> </span><span class="n">ctx</span><span class="p">)</span>
         <span class="o">|</span> <span class="nc">Tuple</span><span class="p">(</span><span class="bp">expr</span><span class="o">* </span><span class="n">elts</span>, <span class="bp">expr_context</span><span class="o"> </span><span class="n">ctx</span><span class="p">)</span>

         <span class="c c-Singleline">-- can appear only in Subscript</span>
         <span class="o">|</span> <span class="nc">Slice</span><span class="p">(</span><span class="bp">expr</span><span class="o">? </span><span class="n">lower</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">upper</span><span class="p">)</span>

          <span class="c c-Singleline">-- col_offset is the byte offset in the utf8 string the parser uses</span>
          <span class="nb">attributes</span> <span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">col_offset</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_lineno</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_col_offset</span><span class="p">)</span>

    <span class="n">expr_context</span> <span class="o">=</span> <span class="nc">Load</span> <span class="o">|</span> <span class="nc">Store</span> <span class="o">|</span> <span class="nc">Del</span>

    <span class="n">boolop</span> <span class="o">=</span> <span class="nc">And</span> <span class="o">|</span> <span class="nc">Or</span>

    <span class="n">location</span> <span class="o">=</span> <span class="nc">Heap</span> <span class="o">|</span> <span class="nc">Stack</span>

    <span class="n">topology</span> <span class="o">=</span> <span class="nc">Cyclic</span> <span class="o">|</span> <span class="nc">Acyclic</span>

    <span class="n">operator</span> <span class="o">=</span> <span class="nc">Add</span> <span class="o">|</span> <span class="nc">Sub</span> <span class="o">|</span> <span class="nc">Mult</span> <span class="o">|</span> <span class="nc">MatMult</span> <span class="o">|</span> <span class="nc">Div</span> <span class="o">|</span> <span class="nc">Mod</span> <span class="o">|</span> <span class="nc">Pow</span> <span class="o">|</span> <span class="nc">LShift</span>
                 <span class="o">|</span> <span class="nc">RShift</span> <span class="o">|</span> <span class="nc">BitOr</span> <span class="o">|</span> <span class="nc">BitXor</span> <span class="o">|</span> <span class="nc">BitAnd</span> <span class="o">|</span> <span class="nc">FloorDiv</span>

    <span class="n">unaryop</span> <span class="o">=</span> <span class="nc">Invert</span> <span class="o">|</span> <span class="nc">Not</span> <span class="o">|</span> <span class="nc">UAdd</span> <span class="o">|</span> <span class="nc">USub</span>

    <span class="n">cmpop</span> <span class="o">=</span> <span class="nc">Eq</span> <span class="o">|</span> <span class="nc">NotEq</span> <span class="o">|</span> <span class="nc">Lt</span> <span class="o">|</span> <span class="nc">LtE</span> <span class="o">|</span> <span class="nc">Gt</span> <span class="o">|</span> <span class="nc">GtE</span> <span class="o">|</span> <span class="nc">Is</span> <span class="o">|</span> <span class="nc">IsNot</span> <span class="o">|</span> <span class="nc">In</span> <span class="o">|</span> <span class="nc">NotIn</span>

    <span class="n">arguments</span> <span class="o">=</span> <span class="p">(</span><span class="bp">arg</span><span class="o">* </span><span class="n">posonlyargs</span>, <span class="bp">arg</span><span class="o">* </span><span class="n">args</span>, <span class="bp">arg</span><span class="o">? </span><span class="n">vararg</span>, <span class="bp">arg</span><span class="o">* </span><span class="n">kwonlyargs</span>,
                 <span class="bp">expr</span><span class="o">* </span><span class="n">kw_defaults</span>, <span class="bp">arg</span><span class="o">? </span><span class="n">kwarg</span>, <span class="bp">expr</span><span class="o">* </span><span class="n">defaults</span><span class="p">)</span>

    <span class="n">arg</span> <span class="o">=</span> <span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">arg</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">annotation</span>, <span class="bp">string</span><span class="o">? </span><span class="n">type_comment</span><span class="p">)</span>
           <span class="nb">attributes</span> <span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">col_offset</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_lineno</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_col_offset</span><span class="p">)</span>

    <span class="c c-Singleline">-- keyword arguments supplied to call (NULL identifier for **kwargs)</span>
    <span class="n">keyword</span> <span class="o">=</span> <span class="p">(</span><span class="bp">identifier</span><span class="o">? </span><span class="n">arg</span>, <span class="bp">expr</span><span class="o"> </span><span class="n">value</span><span class="p">)</span>
               <span class="nb">attributes</span> <span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">col_offset</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_lineno</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_col_offset</span><span class="p">)</span>

    <span class="c c-Singleline">-- import name with optional 'as' alias.</span>
    <span class="n">alias</span> <span class="o">=</span> <span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">name</span>, <span class="bp">identifier</span><span class="o">? </span><span class="n">asname</span><span class="p">)</span>
             <span class="nb">attributes</span> <span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">col_offset</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_lineno</span>, <span class="bp">int</span><span class="o">? </span><span class="n">end_col_offset</span><span class="p">)</span>

    <span class="n">type_ignore</span> <span class="o">=</span> <span class="nc">TypeIgnore</span><span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">string</span><span class="o"> </span><span class="n">tag</span><span class="p">)</span>

    <span class="n">type_param</span> <span class="o">=</span> <span class="nc">TypeVar</span><span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">name</span>, <span class="bp">expr</span><span class="o">? </span><span class="n">bound</span><span class="p">)</span>
               <span class="o">|</span> <span class="nc">ParamSpec</span><span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">name</span><span class="p">)</span>
               <span class="o">|</span> <span class="nc">TypeVarTuple</span><span class="p">(</span><span class="bp">identifier</span><span class="o"> </span><span class="n">name</span><span class="p">)</span>
               <span class="nb">attributes</span> <span class="p">(</span><span class="bp">int</span><span class="o"> </span><span class="n">lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">col_offset</span>, <span class="bp">int</span><span class="o"> </span><span class="n">end_lineno</span>, <span class="bp">int</span><span class="o"> </span><span class="n">end_col_offset</span><span class="p">)</span>
<span class="p">}</span>
</pre>

<h1 id="compiler-pipeline">Compiler pipeline<a class="headerlink" href="#compiler-pipeline" title="Permanent link"></a></h1>
<p>Mylang source &ndash;&gt; Preprocessor &ndash;&gt; Python AST parse &ndash;&gt; Static analysis &ndash;&gt; Mylang AST &ndash;&gt; ????? &ndash;&gt; Rust source code</p>
<h1 id="type-deduction-algorithm">Type deduction algorithm<a class="headerlink" href="#type-deduction-algorithm" title="Permanent link"></a></h1>
<p>When deducing types, it is not always immediately obvious what the types are. Take the following example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">add_2</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">add_2</span><span class="p">(</span><span class="mf">6.7</span><span class="p">)</span>
</pre></div>

<p>when we look to the function <code>add_2</code> on its own, there is nothing indicating the type of <code>x</code> or the return value. The parameter <code>x</code> could be many different types, so instead of defining it by type we define by requrement. There is only the requirement that <code>x</code> implement <code>__add__(int)</code>. To show this we annotate variables we don&rsquo;t know the type of with a &lsquo;%&rsquo;, so when we analyse the function on its own we have</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">%</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">%</span><span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
</pre></div>

<p>where the requirement for %1 is that it implements <code>__add__(int)</code>, and there is no requirement for %2. For variables that can only be one type, we use &lsquo;$&rsquo; notation. For example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">return_1</span><span class="p">():</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">return_1</span><span class="p">()</span>
</pre></div>

<p>there is only one implementation of <code>return_1</code>, so the return value type is known:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">return_1</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="err">$</span><span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">x</span><span class="p">:</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="n">return_1</span><span class="p">()</span>
</pre></div>

<p>Here is an example with both type variables and requirement variables:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">add_2</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">add_2</span><span class="p">(</span><span class="mf">6.7</span><span class="p">)</span>
</pre></div>

<p>It is not clear from the function what type <code>x</code> is, so we must deduce it from calls:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">%</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">%</span><span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="n">add_2</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">b</span><span class="p">:</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="n">add_2</span><span class="p">(</span><span class="mf">6.7</span><span class="p">)</span>
</pre></div>

<p>when we try the call to <code>add_2</code> we don&rsquo;t have any types for the argument or return value. So we must create a copy of <code>add_2</code> that takes <code>5</code> as its argument. We first test to make sure that the paramter passed, <code>5</code> satisfies the requrement of <code>%1</code> (in this case <code>5</code> must implement <code>__add__(int)</code>). It does, so we create a copy of <code>add_2</code> taking an integer as an argument. We can also use the full implementation of <code>__add__(int)</code> to know the return type of this new function, also int. We do this again with <code>6.7</code> as the argument and the result is similar except the argument and return value are both <code>float</code>. This results in an intermediate form looking like:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2_int_int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">add_2_float_float</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span><span class="p">:</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="n">add_2_int_int</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">b</span><span class="p">:</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="n">add_2_float_float</span><span class="p">(</span><span class="mf">6.7</span><span class="p">)</span>
</pre></div>

<p>Note that for the add functions we have a) mangled the names and b) filled in the type variables with explicit types. We know these types because they were created from the previous step. Finally we can deduce the types <code>$1</code> and <code>$2</code> to give</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2_int_int</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>

<span class="k">def</span> <span class="nf">add_2_float_float</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">add_2_int_int</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">add_2_float_float</span><span class="p">(</span><span class="mf">6.7</span><span class="p">)</span>
</pre></div>

<p>The big question is, &lsquo;Can we deduce a functions argument and return types based on the body alone?&rsquo;</p>
<h2 id="mixed">Mixed<a class="headerlink" href="#mixed" title="Permanent link"></a></h2>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">minus_2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
</pre></div>

<p>we do not know the type of <code>x</code> from this, however because <code>range.__next__</code> returns an int, we can say that <code>i</code> is an int:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">minus_2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">%</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>
</pre></div>

<p>and we can say that <code>%1</code> must implement <code>__len__</code>, <code>__getitem__(int) -&gt; %2</code> and <code>__setitem__(int, %2)</code> where <code>%2</code> implements <code>__sub__(int)</code>.</p>
<h2 id="explicit-annotations">Explicit annotations<a class="headerlink" href="#explicit-annotations" title="Permanent link"></a></h2>
<p>The user can explicitly annotate types as such:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">2</span>
</pre></div>

<p>in the above example there is exactly one implementaion of <code>add_2</code>. If the user tries something like <code>add_2(4)</code> this will fail as there is no implementation for <code>int</code>. Also note how no return value is provided as this can be deduced from the return type. The converse is not true, it is not possible to deduce from return value. The following example</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

<p>means that <code>x</code> can be any value as long as <code>__add__(int)</code> is defined and <code>__float__</code> is defined on its return value. The <code>float</code> function is needed to ensure whatever <code>x</code> we use we return a float. Multiple implementations of a function can be defined for arguments as long as they are not explicitly annotated. The following example can accept any type for <code>x</code> as long as it implements <code>__add__(float)</code>. However only <code>float</code> can be accepted for <code>y</code>.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>

<h2 id="deduction-for-init">Deduction for init<a class="headerlink" href="#deduction-for-init" title="Permanent link"></a></h2>
<p>Consider two statements:</p>
<ul>
<li>Statement 1: The type of class fields must be deductable with just ONE possible type. So this is fine:</li>
</ul>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>

<p>because there is only one possible type for <code>self.x</code>, <code>int</code>. However this is not:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="c1"># Here self.x is deduced as int</span>
    <span class="n">a_2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mf">43.0</span><span class="p">)</span> <span class="c1"># But here it is deduced as float. Error!</span>
</pre></div>

<ul>
<li>Statement 2: When init is used to create a class, duck typing can be used</li>
</ul>
<p>These may seem mutually exclusive, however we can have our cake and eat it. Lets say we want to store a value in a class as a float, but take any argument that can be converted to float. We can use the following:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a_1</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">a_2</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mf">43.0</span><span class="p">)</span>
</pre></div>

<p>Since <code>__float__</code> always returns <code>float</code>, we always know that the type of <code>self.x</code> is also float. Two difference copies of <code>init</code> are made one accepting <code>float</code> and one <code>int</code> but both result in <code>self.x</code> being a float.</p>
<h1 id="inference-algorithm">Inference algorithm<a class="headerlink" href="#inference-algorithm" title="Permanent link"></a></h1>
<h2 id="definitions">Definitions<a class="headerlink" href="#definitions" title="Permanent link"></a></h2>
<ul>
<li>All functions with at least one argument that is not explicitly typed is treated as polymorphic so</li>
</ul>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>

<p>are polymorphic but</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>

<p>are not.</p>
<ul>
<li>
<p>Variables labelled with the <code>%</code> symbol indicate that they can be any type so long as they fulfill a set of requrements. </p>
</li>
<li>
<p>A requirement represents a function that a type must contain. The variables on requirement function can contain requirements.</p>
</li>
<li>
<p>Variables laballed with the <code>$</code> symbol indicate that they can be exactly one type</p>
</li>
</ul>
<h2 id="labelling">Labelling<a class="headerlink" href="#labelling" title="Permanent link"></a></h2>
<p>First we iterate over all local variables, function arguments and return statements and label each with a unique type variable. We assume all variables are <code>%</code> variables until proven otherwise. So with</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">sub_2</span><span class="p">(</span><span class="n">container</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="p">)):</span>
        <span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">container</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">sub_2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sub_2</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>

<p>we get something like </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">sub_2</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="o">%</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">%</span><span class="mi">2</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">:</span> <span class="o">%</span><span class="mi">3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">container</span><span class="p">)):</span>
        <span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">container</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">container</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">sub_2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sub_2</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>

<p>and we expand into special functions to give</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">sub_2</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="o">%</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">%</span><span class="mi">2</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">:</span> <span class="o">%</span><span class="mi">3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">__len__</span><span class="p">()):</span>
        <span class="n">container</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">__sub__</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">container</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">sub_2</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sub_2</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>

<h2 id="rules">Rules<a class="headerlink" href="#rules" title="Permanent link"></a></h2>
<p>Next we iterate over the code to learn as much about our type variables as possible. In this case we have:</p>
<ul>
<li>%1<ul>
<li>$1 must implement the function <code>__getitem__(int) -&gt; %6</code>, where $6 implements <code>__subtract__(int) -&gt; %7</code></li>
<li>$1 must implement the function <code>__setitem__(int, %8)</code></li>
</ul>
</li>
<li>%2<ul>
<li>%2 = %1, because the return value is <code>container</code> which has type <code>%1</code></li>
</ul>
</li>
<li>%3<ul>
<li>We have to do a little digging for this one. Given <code>for a in b</code>, the type of <code>a</code> is deduced by first finding the type <code>b.__iter__()</code>, then in that type we find <code>__next__()</code>, and <code>a</code> is the same type as the return value for <code>__next__()</code> (without the some). In this case, <code>range.__iter__()</code> is type <code>IterRange</code>, and its <code>__next__()</code> function always returns int. So
%3 = int.</li>
</ul>
</li>
<li>%4<ul>
<li>RHS of assignment is <code>List&lt;int&gt;</code> so %4 = <code>List&lt;int&gt;</code></li>
</ul>
</li>
<li>%5<ul>
<li>RHS of assignment is <code>List&lt;float&gt;</code> so %5 = <code>List&lt;int&gt;</code></li>
</ul>
</li>
<li>%6<ul>
<li>As mentioned, %6 must implement <code>__subtract__(int)</code></li>
</ul>
</li>
<li>%7<ul>
<li>There are no restrictions on %7</li>
</ul>
</li>
<li>%8<ul>
<li>%8 = %7 because the return value of the substraction is fed into the <code>__setitem__</code> function, and these have type variables %7 and %8, respectively.</li>
</ul>
</li>
</ul>
<h2 id="function-calls">Function calls<a class="headerlink" href="#function-calls" title="Permanent link"></a></h2>
<p>For each function call we make sure that the parameters &lsquo;fit&rsquo;. That is, if the function is not polymorphic, we check that the parameters fit the explicit types. If it is, we make sure that the parameters fulfill any requirements discovered in the Rules phase. In the above example we have two calls:</p>
<pre><code>- sub_2(x): We know that `x` has type `List&lt;int&gt;` so we test the two implementation requirements:
    - x does implement the function `__getitem__(int) -&gt; $6`
    - in this case, $6 = int
    - $6 implements `__subtract__(int) -&gt; $7`
    - $7 = int

- sub_2(y): We know that `x` has type `List&lt;float&gt;` so we test the two implementation requirements:
    - x does implement the function `__getitem__(float) -&gt; $6`
    - in this case, $6 = float
    - $6 implements `__subtract__(float) -&gt; $7`
    - $7 = float
</code></pre>
<p>we now create two mangled versions of <code>sub_2</code> copying the code and creating new type variables with the same rules:</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">sub_2_a</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">__len__</span><span class="p">()):</span>
        <span class="n">container</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">__sub__</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">container</span>

<span class="k">def</span> <span class="nf">sub_2_b</span><span class="p">(</span><span class="n">container</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span><span class="p">:</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">container</span><span class="o">.</span><span class="n">__len__</span><span class="p">()):</span>
        <span class="n">container</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">__sub__</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">container</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">List</span><span class="o">&lt;</span><span class="nb">float</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">7.2</span><span class="p">,</span> <span class="mf">4.9</span><span class="p">,</span> <span class="mf">5.1</span><span class="p">]</span>

    <span class="k">print</span><span class="p">(</span><span class="n">sub_2_a</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">sub_2_b</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
</pre></div>

<h2 id="unification">Unification<a class="headerlink" href="#unification" title="Permanent link"></a></h2>
<p>Follow the steps outlined in the unification algorithm outlined <a href="https://www.cmi.ac.in/~madhavan/courses/pl2009/lecturenotes/lecture-notes/node113.html">here</a></p>
<h2 id="algorithm">Algorithm<a class="headerlink" href="#algorithm" title="Permanent link"></a></h2>
<p>We keep performing the steps in the function calls and unification steps until we either have an error or a substitution mapping type variables to types.</p>
<h1 id="structure">Structure<a class="headerlink" href="#structure" title="Permanent link"></a></h1>
<h2 id="types">Types<a class="headerlink" href="#types" title="Permanent link"></a></h2>
<p>Here we have a list of all types that a variable can be</p>
<ul>
<li>bool</li>
<li>int</li>
<li>float</li>
<li>complex</li>
<li>string</li>
<li>path</li>
<li>bytes</li>
<li>list<T></li>
<li>map<K, V></li>
<li>set<K></li>
<li>option<T></li>
<li>result<T, E></li>
<li>function pointer<List of types for each parameter, One or none types for the return value></li>
<li>user defined type<String value with the name of the type></li>
</ul>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">Bool</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nb">Int</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nb">Float</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Complex</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nb">Path</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">Bytes</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">List</span><span class="p">{</span><span class="w"> </span><span class="n">item</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="nb">Map</span><span class="p">{</span><span class="w"> </span><span class="n">key</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="nb">Set</span><span class="p">{</span><span class="w"> </span><span class="n">element</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="nb">Option</span><span class="p">{</span><span class="w"> </span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="nb">Result</span><span class="p">{</span><span class="w"> </span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="o">:</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">FunctionPointer</span><span class="p">{</span><span class="w"> </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="n">Class</span><span class="p">{</span><span class="w"> </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="p">},</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Identifier used to represent type variables in the unification algorithm</span>
<span class="w">    </span><span class="n">TypeIdentifier</span><span class="p">(</span><span class="kt">u64</span><span class="p">),</span><span class="w"></span>

<span class="w">    </span><span class="c1">//Used to resolve requirements. This allows the values of containers to be expressed as requirements rather than explicit types</span>
<span class="w">    </span><span class="n">Requirement</span><span class="p">(</span><span class="n">Requirement</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h2 id="requirement">Requirement<a class="headerlink" href="#requirement" title="Permanent link"></a></h2>
<p>Requirements could be as simple as &lsquo;Implement the <code>__xyz__()</code> function&rsquo;, or as complicated as &lsquo;Implement the <code>__iter()__ -&gt; $1</code> function where $1 implements <code>__next__() -&gt; $2</code> where $2 implements <code>some_function($3, int) -&gt; $4</code> where $3 implements <code>__float__()</code> and $4 has no requirements&rsquo;.</p>
<p>Requirements can be a type. This is how we implement explicit types.</p>
<p>Requirements can be one of the following</p>
<div class="highlight"><pre><span class="k">struct</span><span class="w"> </span><span class="n">FunctionRequirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">String</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">Requirement</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Requirement</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">enum</span><span class="w"> </span><span class="n">Requirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">//To match, the matchee must have type given</span>
<span class="w">    </span><span class="n">ExplicitType</span><span class="p">(</span><span class="n">Type</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="c1">//To match, the matchee must implement each of the functions in the list</span>
<span class="w">    </span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">FunctionRequirement</span><span class="o">&gt;</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Matches any matchee</span>
<span class="w">    </span><span class="n">NoRequirements</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="c1">//Placeholder - Used where we don&#39;t have an explicit type just yet</span>
<span class="w">    </span><span class="n">Placeholder</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<h3 id="examples">Examples<a class="headerlink" href="#examples" title="Permanent link"></a></h3>
<p>&lsquo;Implement the <code>__xyz__()</code> function&rsquo; would evaluate to</p>
<div class="highlight"><pre><span class="n">Requirement</span><span class="o">::</span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">FunctionRequirement</span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;__xyz__&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">}]</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>

<p>and &lsquo;Implement the <code>__iter()__ -&gt; $1</code> function where $1 implements <code>__next__() -&gt; $2</code> where $2 implements <code>some_function($3, int) -&gt; $4</code> where $3 implements <code>__float__() -&gt; float</code>, $4 has no requirements and $2 also implements <code>some_other_function()</code> would evaluate to</p>
<div class="highlight"><pre><span class="n">Requirement</span><span class="o">::</span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">FunctionRequirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">        </span><span class="n">name</span><span class="o">:</span><span class="s">&quot;__iter__&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="n">Requirement</span><span class="o">::</span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">FunctionRequirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">            </span><span class="n">name</span><span class="o">:</span><span class="s">&quot;__next__&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Requirement</span><span class="o">::</span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">FunctionRequirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">                </span><span class="n">name</span><span class="o">:</span><span class="s">&quot;some_function&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="w"> </span><span class="n">Requirement</span><span class="o">::</span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">FunctionRequirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                            </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;__float__&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">                            </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="n">Requirement</span><span class="o">::</span><span class="n">ExplicitType</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="nb">Float</span><span class="p">),</span><span class="w"></span>
<span class="w">                        </span><span class="p">}</span><span class="w"></span>

<span class="w">                        </span><span class="p">]),</span><span class="w"></span>
<span class="w">                    </span><span class="n">Requirement</span><span class="o">::</span><span class="n">ExplicitType</span><span class="p">(</span><span class="n">Type</span><span class="o">::</span><span class="nb">Int</span><span class="p">)]),</span><span class="w"></span>
<span class="w">                </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Requirement</span><span class="o">::</span><span class="n">NoRequirements</span><span class="p">),</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="n">FunctionRequirement</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">name</span><span class="o">:</span><span class="s">&quot;some_other_function&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>

<span class="w">            </span><span class="p">,</span><span class="w"></span>
<span class="w">            </span><span class="p">]))</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="p">])</span><span class="w"></span>
</pre></div>

<p>finally we have</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

<p>which evaluates to </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">%</span><span class="mi">3</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

<p>and from this we have the requirement &lsquo;x implements <code>__call__(%2)</code> where %2 has no requirements&rsquo; this can be formalised as</p>
<div class="highlight"><pre><span class="n">Requirement</span><span class="o">::</span><span class="n">ImplementsFunctions</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">FunctionRequirement</span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="s">&quot;__call__&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">args</span><span class="o">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">Requirement</span><span class="o">::</span><span class="n">NoRequirements</span><span class="p">]),</span><span class="w"></span>
<span class="w">        </span><span class="n">ret</span><span class="o">:</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="n">Requirement</span><span class="o">::</span><span class="n">NoRequirements</span><span class="p">]),</span><span class="w"></span>
<span class="w">    </span><span class="p">}]</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</pre></div>

<p>when we make a call to <code>f</code>, we check the requirement on <code>x</code>. If it is satisfied, we create a copy of <code>f</code> filling out all the types.</p>
<h3 id="fallbackss">Fallbackss<a class="headerlink" href="#fallbackss" title="Permanent link"></a></h3>
<p>As mentioned, for each function call, we test each parameter make sure they match the requirements of the function. In fact, the algorithm is more general than this because poly functions can have multiple definitions indicating fallback functions. So we keep testing requirements on each of the fallback definitions until we find a function that matches, or if we run out of fallbacks and none of them match, we have a type error. Take the following example:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">&quot;str&quot;</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">&quot;repr&quot;</span>

<span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">__repr__</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="k">print</span><span class="p">(</span><span class="n">to_string</span><span class="p">(</span><span class="n">A</span><span class="p">()))</span>

    <span class="k">print</span><span class="p">(</span><span class="n">to_string</span><span class="p">(</span><span class="n">B</span><span class="p">()))</span>
</pre></div>

<p>The first implementation of <code>to_string</code> has the &lsquo;x implements <code>__str__()</code> function&rsquo; and the second implementation has the &lsquo;x implements <code>__repr__()</code> function&rsquo;. So in our first call to <code>to_string</code>, we check the criteria for <code>A</code>. Since it does fulfill the requirements we have found a match and create a copy of <code>to_string</code> that takes <code>A</code> as an argument. Next we take the second call. We test <code>B</code> for the requrement, which fails since it does not implement <code>__str__</code>, so we fallback to the next implementation. Since <code>B</code> meets these requirements, we create a copy of the second <code>to_string</code> implementation which takes <code>B</code> as an argument.</p>
<h2 id="equation-list">Equation list<a class="headerlink" href="#equation-list" title="Permanent link"></a></h2>
<p>A list of equations of the form <code>a = b</code> where a and be can be types or type variables. Equations can look like</p>
<ul>
<li>$1 = int</li>
<li>$2 = $3</li>
<li>bool = $4</li>
<li>$4 = $4</li>
<li>bool = bool</li>
<li>bool = int</li>
</ul>
<p>The set of equations is implemented as a list of pairs. A pair is made of two terms, the LHS and the RHS of the equality. Terms are defined as followed:</p>
<div class="highlight"><pre><span class="k">enum</span><span class="w"> </span><span class="n">Term</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">ExplicitType</span><span class="p">(</span><span class="n">Type</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">TypeVariable</span><span class="p">(</span><span class="kt">u64</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>so the set is defined as <code>Vec&lt;(Term, Term)&gt;</code>. For each pair there are 4 cases:</p>
<ul>
<li>TypeVariable, TypeVariable: in this case we have $n = $m, so we replace all occurences of $n with $m, or vise versa</li>
<li>ExplicitType, TypeVariable: in this case we swap the two, so TYPE = $n becomes $n = TYPE.</li>
<li>TypeVariable, ExplicitType: in this case we have $n = TYPE so we do nothing</li>
<li>ExplicitType, ExplicitType: In this case we have TYPE_a = TYPE_b. If the types are the same and simple types, remove it from the set as it is redundant. If they are different, this represents a type error. If they are poly types and the same, (list, option, etc.) then equate the internal types. So V&lt;$2, int&gt; = V<bool, int> becomes $2 = bool and int = int. If they are poly types and different, this is a type error.</li>
</ul>
<h3 id="overloading">Overloading<a class="headerlink" href="#overloading" title="Permanent link"></a></h3>
<p>We can use the requirement and fallback systems together to allow function overloading. Take the following</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">string</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>

<p>Since requirements can include explicit types, any number of arguments and nested requirements, we can use this with the fallback system to deduce function overloads. Just as before, we can check the arguments of function calls against the definitions one at a time until we find a match.</p>
<h1 id="init-polymorphism">Init polymorphism<a class="headerlink" href="#init-polymorphism" title="Permanent link"></a></h1>
<p>We can create templates for classes based on the requirements of the member variables. Take the following</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>  
</pre></div>

<p>converting the syntactic sugar we have</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Complex</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>

    <span class="c1"># Since no getters or setters were explicitly implemented, Mylang provides these defaults</span>
    <span class="k">def</span> <span class="nf">__set_real__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">real</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="n">real</span>

    <span class="k">def</span> <span class="nf">__get_real_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">real</span>

    <span class="k">def</span> <span class="nf">__set_imag__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imag</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="n">imag</span>

    <span class="k">def</span> <span class="nf">__get_imag_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__get_real__</span><span class="p">()</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__get_real__</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_imag_</span><span class="p">()</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__get_imag_</span><span class="p">()))</span>
</pre></div>

<p>In the above example, we see that <code>__init__</code> has no requirements itself, however the <code>__add__</code> function does. From this we see that the requirements on emmber variables are a sum of all the requirements on all the member variables in all the member functions. In this case we just have the requirment that <code>real</code> implements <code>__add__($1)</code> where $1 implements <code>__get_real__</code>. Note that <code>other</code> in <code>__add__</code> has requirements itself, and are separate from <code>real</code>&lsquo;s requiremnts. From this we have two important results:</p>
<ul>
<li>Requirements on non-member function variables resuts in the individual function being templated</li>
<li>Requirements on member variables (anything on <code>self</code>) results in the class being templated.</li>
</ul>
<p>So in the above example, if we use <code>Complex(int, int)</code> and <code>Complex(float, float)</code>, this creates two templates of <code>Complex</code>. Next we use our implementation of zip to demonstrate class templating:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Zip</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">iter_a</span><span class="p">,</span> <span class="n">iter_b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">iter_a</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">iter_b</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">():</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">__next__</span><span class="p">()</span>

        <span class="c1"># Stop the iterator as soon as either zip is finished</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_none</span><span class="p">()</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_none</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">some</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</pre></div>

<p>in the above example we see that the type of <code>self.a</code> is decided by <code>iter_a.__iter__()</code>. And <code>__iter__</code> is a special function, but it doesn&rsquo;t have a set return type. So we must go to <code>iter_a</code> for answers, but again this variable&rsquo;s type is not explicit, so we cannot tell from the definition. We cannot tell from the definiton. To make things more general, we treat class generics the way we treat function generics. We treat monomorphic and polymorphic classes the same. </p>
<p>First we create a set of requirements for each member variable. In this case, we have &lsquo;self.a must implement <code>__next__</code>&rsquo;. Next we create requirements for <code>iter_a</code>, namely &lsquo;iter_a must implement <code>__iter__() -&gt; $1</code> where $1 implements <code>__next__</code>.</p>
<p>Now that we have a set of requirements, every time we construct a new <code>Zip</code> we check the requirements on the constructor then from this call we deduce the type of <code>self.a</code>.</p>
<h2 id="exceptions">Exceptions<a class="headerlink" href="#exceptions" title="Permanent link"></a></h2>
<p>There are times when the type cannot be deduced by the constructor alone.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Container</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</pre></div>

<p>This can only happen with container type. Namely</p>
<ul>
<li>List types (Lists)</li>
<li>Map types (Dictionaries, sets, etc.)</li>
<li>Option</li>
</ul>
<p>this can be resolved by deducing the type from certain functions that each type has. For example</p>
<ul>
<li><code>append</code>, <code>insert</code> for list types</li>
<li><code>insert</code> for map types</li>
<li><code>some</code> for option</li>
</ul>
<p>also sometimes we can look at the initialisation to deduce type, for example <code>[2, 5, 4]</code> and <code>{ "fred": 2.3, "mike": 6.5 }</code>.</p>
<h2 id="misleading">Misleading<a class="headerlink" href="#misleading" title="Permanent link"></a></h2>
<p>Some classes look like they will be templated, but it might only be the <code>__init__</code> function that is templated:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Int</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mf">4.5</span><span class="p">)</span>
</pre></div>

<p>it might look as though <code>Int</code> would be templated for integers and floats. However the constructor converts every value into a float in its implementation, which means that the <code>__init__</code> function is templated. The <code>float</code> function always returns a Mylang float, so only one version of <code>Int</code> will ever be made, that is where <code>self.value</code> is a float. However in the next example, two class templates are made as the values are stored directly and not converted:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Int</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mf">4.5</span><span class="p">)</span>
</pre></div>

<h2 id="summary">Summary<a class="headerlink" href="#summary" title="Permanent link"></a></h2>
<p>The rules for class vs function templating are very simple:</p>
<ul>
<li>Class templating is performed based on the member variables</li>
<li>Function templating is performed based on the function parameters.</li>
</ul>
<p>and the way we test for compatibility (via requirements) and deduce type works the same way for both systems. In fact the algorithm is exactly the same, the only difference is instead of looking at function arguments, we look at member variables.</p>
<h1 id="self-problem">Self problem<a class="headerlink" href="#self-problem" title="Permanent link"></a></h1>
<p>When we call the <code>self</code> variable as is in Rust, this gives a reference to the instantiated object. In Mylang this should be the same, except with stack types it should make a copy of the object, but with heap objects this must return a reference counted RC or GC type. </p>
<p>The problem is that if we have a Rust class <code>A</code>, then <code>self</code> within <code>A</code> returns an <code>A</code>, whereas it should return a <code>Rc&lt;UnsafeCell&lt;A&gt;&gt;</code>.</p>
<p>We could secretly include a reference to the object in each custom heap structure, however this will mean that every object becomes a cycle and will invalidate reference counting. This could be fixed with a weak reference but this would still add memory overhead to each structure.</p>
<p>What we must do instead is for each <code>self</code> object we must convert it to a <code>Rc&lt;UnsafeCell&lt;A&gt;&gt;</code> then clone it to respect the reference counting rules. We can do this with roughly the following:</p>
<ul>
<li>Obtain a pointer to <code>self</code></li>
<li>Since this pointer points to an <code>A</code> that exists within a <code>Rc&lt;UnsafeCell&lt;A&gt;&gt;</code>, we must decrement N bytes where N is the size in bytes of all the data before <code>A</code></li>
<li>We now have a pointer at the beginning of <code>Rc&lt;UnsafeCell&lt;A&gt;&gt;</code>, so we cast this back to a <code>Rc&lt;UnsafeCell&lt;A&gt;&gt;</code> object.</li>
<li>Finally we clone this object to obtain a new reference to <code>A</code> that respects the reference counting rules.</li>
</ul>
<p>NOTE: These rules only apply when we are obtaining <code>self</code> on its own. This does not apply to members variable access like <code>self.a</code> as tha <code>a</code> is stored as a reference counted object anyway or is stack allocated and moved by value. I propose a functions something like</p>
<div class="highlight"><pre><span class="k">fn</span><span class="w"> </span><span class="n">filthy_cast_to_rc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">filthy_cast_to_rgc</span><span class="o">::&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">filthy_cast_to_gc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">filthy_cast_to_rgc</span><span class="o">::&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Gc</span><span class="o">&lt;</span><span class="n">UnsafeCell</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span><span class="w"> </span><span class="n">filthy_cast_to_rgc</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">R</span><span class="o">:</span><span class="w"> </span><span class="nb">Clone</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">number_of_counts</span><span class="o">:</span><span class="w"> </span><span class="n">isize</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Convert the reference to t into a pointer to t</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">t_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// convert this pointer to t into a pointer to bytes (used for offset function)</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_pointer</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// The RcBox type contains two usize counts (strong and weak counts) then the data.</span>
<span class="w">        </span><span class="c1">// So to go from the data to the beginning of the RcBox struct, we subtract two usizes worth of bytes from the pointer.</span>
<span class="w">        </span><span class="c1">// For the GcBox, we only have one usize (a single strong count) and so we subtract one usize.</span>
<span class="w">        </span><span class="c1">// We supply the number of usizes to subtract as the argument `number_of_counts`</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">box_begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bytes_pointer</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">isize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">-</span><span class="n">number_of_counts</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="c1">//Magical jiggery pokery to convert pointer to u8 into a pointer to Rc&lt;...&gt;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rc_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">box_begin</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="kr">const</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rc_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rc_ref</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">R</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">//Get a regular reference to the Rc&lt;...&gt; object</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rc_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">rc_pointer</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">//Clone the Rc object. This provides a reference to T that respects the reference counting rules</span>
<span class="w">        </span><span class="n">rc_ref</span><span class="p">.</span><span class="n">clone</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>

<p>This unholy abomination above is safe if and only if the function is called on an object <code>t</code> that is itself wrapped in an [RG]c<UnsafeCell\<T>> type, if not this is undefined behaviour.</p>
<h1 id="rough-roadmap-for-inference">Rough roadmap for inference<a class="headerlink" href="#rough-roadmap-for-inference" title="Permanent link"></a></h1>
<ol>
<li>Obtain a dict mapping class names to sets of class member variables</li>
<li>Obtain a dict for each function (global and class) that maps parameters (including member variables for class functions) to a list of requirements. Note: be sure to add requirements for variables recursively, looking at all the member functions for the variables, and functions that are called on the variable.</li>
<li>For each class, decide whether it is stack or heap allocated</li>
<li>Add type variables for each variable</li>
</ol></article></body></html>